// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_NETWORKENGINETOFRONTEND_NETWORKENGINETOFRONTEND_H_
#define FLATBUFFERS_GENERATED_NETWORKENGINETOFRONTEND_NETWORKENGINETOFRONTEND_H_

#include "flatbuffers/flatbuffers.h"

namespace NetworkEngineToFrontEnd {

struct CurrentWeatherConditions;
struct CurrentWeatherConditionsBuilder;

struct ForecastWeatherConditions;
struct ForecastWeatherConditionsBuilder;

struct WeatherData;
struct WeatherDataBuilder;

struct DateTimeData;
struct DateTimeDataBuilder;

struct Packet;
struct PacketBuilder;

enum Data {
  Data_NONE = 0,
  Data_WeatherData = 1,
  Data_DateTimeData = 2,
  Data_MIN = Data_NONE,
  Data_MAX = Data_DateTimeData
};

inline const Data (&EnumValuesData())[3] {
  static const Data values[] = {
    Data_NONE,
    Data_WeatherData,
    Data_DateTimeData
  };
  return values;
}

inline const char * const *EnumNamesData() {
  static const char * const names[4] = {
    "NONE",
    "WeatherData",
    "DateTimeData",
    nullptr
  };
  return names;
}

inline const char *EnumNameData(Data e) {
  if (flatbuffers::IsOutRange(e, Data_NONE, Data_DateTimeData)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesData()[index];
}

template<typename T> struct DataTraits {
  static const Data enum_value = Data_NONE;
};

template<> struct DataTraits<NetworkEngineToFrontEnd::WeatherData> {
  static const Data enum_value = Data_WeatherData;
};

template<> struct DataTraits<NetworkEngineToFrontEnd::DateTimeData> {
  static const Data enum_value = Data_DateTimeData;
};

bool VerifyData(flatbuffers::Verifier &verifier, const void *obj, Data type);
bool VerifyDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct CurrentWeatherConditions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CurrentWeatherConditionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEMPERATURE = 4,
    VT_MINIMUM_TEMPERATURE = 6,
    VT_MAXIMUM_TEMPERATURE = 8,
    VT_PRESSURE = 10,
    VT_HUMIDITY = 12,
    VT_WIND_SPEED = 14,
    VT_WIND_GUST_SPEED = 16,
    VT_CONDITION_CODE = 18,
    VT_TEXT = 20
  };
  int16_t temperature() const {
    return GetField<int16_t>(VT_TEMPERATURE, 0);
  }
  int16_t minimum_temperature() const {
    return GetField<int16_t>(VT_MINIMUM_TEMPERATURE, 0);
  }
  int16_t maximum_temperature() const {
    return GetField<int16_t>(VT_MAXIMUM_TEMPERATURE, 0);
  }
  uint16_t pressure() const {
    return GetField<uint16_t>(VT_PRESSURE, 0);
  }
  uint8_t humidity() const {
    return GetField<uint8_t>(VT_HUMIDITY, 0);
  }
  uint16_t wind_speed() const {
    return GetField<uint16_t>(VT_WIND_SPEED, 0);
  }
  uint16_t wind_gust_speed() const {
    return GetField<uint16_t>(VT_WIND_GUST_SPEED, 0);
  }
  uint16_t condition_code() const {
    return GetField<uint16_t>(VT_CONDITION_CODE, 0);
  }
  const flatbuffers::String *text() const {
    return GetPointer<const flatbuffers::String *>(VT_TEXT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_TEMPERATURE) &&
           VerifyField<int16_t>(verifier, VT_MINIMUM_TEMPERATURE) &&
           VerifyField<int16_t>(verifier, VT_MAXIMUM_TEMPERATURE) &&
           VerifyField<uint16_t>(verifier, VT_PRESSURE) &&
           VerifyField<uint8_t>(verifier, VT_HUMIDITY) &&
           VerifyField<uint16_t>(verifier, VT_WIND_SPEED) &&
           VerifyField<uint16_t>(verifier, VT_WIND_GUST_SPEED) &&
           VerifyField<uint16_t>(verifier, VT_CONDITION_CODE) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           verifier.EndTable();
  }
};

struct CurrentWeatherConditionsBuilder {
  typedef CurrentWeatherConditions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_temperature(int16_t temperature) {
    fbb_.AddElement<int16_t>(CurrentWeatherConditions::VT_TEMPERATURE, temperature, 0);
  }
  void add_minimum_temperature(int16_t minimum_temperature) {
    fbb_.AddElement<int16_t>(CurrentWeatherConditions::VT_MINIMUM_TEMPERATURE, minimum_temperature, 0);
  }
  void add_maximum_temperature(int16_t maximum_temperature) {
    fbb_.AddElement<int16_t>(CurrentWeatherConditions::VT_MAXIMUM_TEMPERATURE, maximum_temperature, 0);
  }
  void add_pressure(uint16_t pressure) {
    fbb_.AddElement<uint16_t>(CurrentWeatherConditions::VT_PRESSURE, pressure, 0);
  }
  void add_humidity(uint8_t humidity) {
    fbb_.AddElement<uint8_t>(CurrentWeatherConditions::VT_HUMIDITY, humidity, 0);
  }
  void add_wind_speed(uint16_t wind_speed) {
    fbb_.AddElement<uint16_t>(CurrentWeatherConditions::VT_WIND_SPEED, wind_speed, 0);
  }
  void add_wind_gust_speed(uint16_t wind_gust_speed) {
    fbb_.AddElement<uint16_t>(CurrentWeatherConditions::VT_WIND_GUST_SPEED, wind_gust_speed, 0);
  }
  void add_condition_code(uint16_t condition_code) {
    fbb_.AddElement<uint16_t>(CurrentWeatherConditions::VT_CONDITION_CODE, condition_code, 0);
  }
  void add_text(flatbuffers::Offset<flatbuffers::String> text) {
    fbb_.AddOffset(CurrentWeatherConditions::VT_TEXT, text);
  }
  explicit CurrentWeatherConditionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CurrentWeatherConditions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CurrentWeatherConditions>(end);
    return o;
  }
};

inline flatbuffers::Offset<CurrentWeatherConditions> CreateCurrentWeatherConditions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t temperature = 0,
    int16_t minimum_temperature = 0,
    int16_t maximum_temperature = 0,
    uint16_t pressure = 0,
    uint8_t humidity = 0,
    uint16_t wind_speed = 0,
    uint16_t wind_gust_speed = 0,
    uint16_t condition_code = 0,
    flatbuffers::Offset<flatbuffers::String> text = 0) {
  CurrentWeatherConditionsBuilder builder_(_fbb);
  builder_.add_text(text);
  builder_.add_condition_code(condition_code);
  builder_.add_wind_gust_speed(wind_gust_speed);
  builder_.add_wind_speed(wind_speed);
  builder_.add_pressure(pressure);
  builder_.add_maximum_temperature(maximum_temperature);
  builder_.add_minimum_temperature(minimum_temperature);
  builder_.add_temperature(temperature);
  builder_.add_humidity(humidity);
  return builder_.Finish();
}

inline flatbuffers::Offset<CurrentWeatherConditions> CreateCurrentWeatherConditionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t temperature = 0,
    int16_t minimum_temperature = 0,
    int16_t maximum_temperature = 0,
    uint16_t pressure = 0,
    uint8_t humidity = 0,
    uint16_t wind_speed = 0,
    uint16_t wind_gust_speed = 0,
    uint16_t condition_code = 0,
    const char *text = nullptr) {
  auto text__ = text ? _fbb.CreateString(text) : 0;
  return NetworkEngineToFrontEnd::CreateCurrentWeatherConditions(
      _fbb,
      temperature,
      minimum_temperature,
      maximum_temperature,
      pressure,
      humidity,
      wind_speed,
      wind_gust_speed,
      condition_code,
      text__);
}

struct ForecastWeatherConditions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ForecastWeatherConditionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEMPERATURE = 4,
    VT_MINIMUM_TEMPERATURE = 6,
    VT_MAXIMUM_TEMPERATURE = 8,
    VT_PRESSURE = 10,
    VT_HUMIDITY = 12,
    VT_WIND_SPEED = 14,
    VT_WIND_GUST_SPEED = 16,
    VT_CONDITION_CODE = 18,
    VT_TEXT = 20
  };
  int16_t temperature() const {
    return GetField<int16_t>(VT_TEMPERATURE, 0);
  }
  int16_t minimum_temperature() const {
    return GetField<int16_t>(VT_MINIMUM_TEMPERATURE, 0);
  }
  int16_t maximum_temperature() const {
    return GetField<int16_t>(VT_MAXIMUM_TEMPERATURE, 0);
  }
  uint16_t pressure() const {
    return GetField<uint16_t>(VT_PRESSURE, 0);
  }
  uint8_t humidity() const {
    return GetField<uint8_t>(VT_HUMIDITY, 0);
  }
  uint16_t wind_speed() const {
    return GetField<uint16_t>(VT_WIND_SPEED, 0);
  }
  uint16_t wind_gust_speed() const {
    return GetField<uint16_t>(VT_WIND_GUST_SPEED, 0);
  }
  uint16_t condition_code() const {
    return GetField<uint16_t>(VT_CONDITION_CODE, 0);
  }
  const flatbuffers::String *text() const {
    return GetPointer<const flatbuffers::String *>(VT_TEXT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_TEMPERATURE) &&
           VerifyField<int16_t>(verifier, VT_MINIMUM_TEMPERATURE) &&
           VerifyField<int16_t>(verifier, VT_MAXIMUM_TEMPERATURE) &&
           VerifyField<uint16_t>(verifier, VT_PRESSURE) &&
           VerifyField<uint8_t>(verifier, VT_HUMIDITY) &&
           VerifyField<uint16_t>(verifier, VT_WIND_SPEED) &&
           VerifyField<uint16_t>(verifier, VT_WIND_GUST_SPEED) &&
           VerifyField<uint16_t>(verifier, VT_CONDITION_CODE) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           verifier.EndTable();
  }
};

struct ForecastWeatherConditionsBuilder {
  typedef ForecastWeatherConditions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_temperature(int16_t temperature) {
    fbb_.AddElement<int16_t>(ForecastWeatherConditions::VT_TEMPERATURE, temperature, 0);
  }
  void add_minimum_temperature(int16_t minimum_temperature) {
    fbb_.AddElement<int16_t>(ForecastWeatherConditions::VT_MINIMUM_TEMPERATURE, minimum_temperature, 0);
  }
  void add_maximum_temperature(int16_t maximum_temperature) {
    fbb_.AddElement<int16_t>(ForecastWeatherConditions::VT_MAXIMUM_TEMPERATURE, maximum_temperature, 0);
  }
  void add_pressure(uint16_t pressure) {
    fbb_.AddElement<uint16_t>(ForecastWeatherConditions::VT_PRESSURE, pressure, 0);
  }
  void add_humidity(uint8_t humidity) {
    fbb_.AddElement<uint8_t>(ForecastWeatherConditions::VT_HUMIDITY, humidity, 0);
  }
  void add_wind_speed(uint16_t wind_speed) {
    fbb_.AddElement<uint16_t>(ForecastWeatherConditions::VT_WIND_SPEED, wind_speed, 0);
  }
  void add_wind_gust_speed(uint16_t wind_gust_speed) {
    fbb_.AddElement<uint16_t>(ForecastWeatherConditions::VT_WIND_GUST_SPEED, wind_gust_speed, 0);
  }
  void add_condition_code(uint16_t condition_code) {
    fbb_.AddElement<uint16_t>(ForecastWeatherConditions::VT_CONDITION_CODE, condition_code, 0);
  }
  void add_text(flatbuffers::Offset<flatbuffers::String> text) {
    fbb_.AddOffset(ForecastWeatherConditions::VT_TEXT, text);
  }
  explicit ForecastWeatherConditionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ForecastWeatherConditions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ForecastWeatherConditions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ForecastWeatherConditions> CreateForecastWeatherConditions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t temperature = 0,
    int16_t minimum_temperature = 0,
    int16_t maximum_temperature = 0,
    uint16_t pressure = 0,
    uint8_t humidity = 0,
    uint16_t wind_speed = 0,
    uint16_t wind_gust_speed = 0,
    uint16_t condition_code = 0,
    flatbuffers::Offset<flatbuffers::String> text = 0) {
  ForecastWeatherConditionsBuilder builder_(_fbb);
  builder_.add_text(text);
  builder_.add_condition_code(condition_code);
  builder_.add_wind_gust_speed(wind_gust_speed);
  builder_.add_wind_speed(wind_speed);
  builder_.add_pressure(pressure);
  builder_.add_maximum_temperature(maximum_temperature);
  builder_.add_minimum_temperature(minimum_temperature);
  builder_.add_temperature(temperature);
  builder_.add_humidity(humidity);
  return builder_.Finish();
}

inline flatbuffers::Offset<ForecastWeatherConditions> CreateForecastWeatherConditionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t temperature = 0,
    int16_t minimum_temperature = 0,
    int16_t maximum_temperature = 0,
    uint16_t pressure = 0,
    uint8_t humidity = 0,
    uint16_t wind_speed = 0,
    uint16_t wind_gust_speed = 0,
    uint16_t condition_code = 0,
    const char *text = nullptr) {
  auto text__ = text ? _fbb.CreateString(text) : 0;
  return NetworkEngineToFrontEnd::CreateForecastWeatherConditions(
      _fbb,
      temperature,
      minimum_temperature,
      maximum_temperature,
      pressure,
      humidity,
      wind_speed,
      wind_gust_speed,
      condition_code,
      text__);
}

struct WeatherData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WeatherDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CURRENT = 4,
    VT_FORECAST = 6
  };
  const NetworkEngineToFrontEnd::CurrentWeatherConditions *current() const {
    return GetPointer<const NetworkEngineToFrontEnd::CurrentWeatherConditions *>(VT_CURRENT);
  }
  const flatbuffers::Vector<flatbuffers::Offset<NetworkEngineToFrontEnd::ForecastWeatherConditions>> *forecast() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<NetworkEngineToFrontEnd::ForecastWeatherConditions>> *>(VT_FORECAST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CURRENT) &&
           verifier.VerifyTable(current()) &&
           VerifyOffset(verifier, VT_FORECAST) &&
           verifier.VerifyVector(forecast()) &&
           verifier.VerifyVectorOfTables(forecast()) &&
           verifier.EndTable();
  }
};

struct WeatherDataBuilder {
  typedef WeatherData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_current(flatbuffers::Offset<NetworkEngineToFrontEnd::CurrentWeatherConditions> current) {
    fbb_.AddOffset(WeatherData::VT_CURRENT, current);
  }
  void add_forecast(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NetworkEngineToFrontEnd::ForecastWeatherConditions>>> forecast) {
    fbb_.AddOffset(WeatherData::VT_FORECAST, forecast);
  }
  explicit WeatherDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<WeatherData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WeatherData>(end);
    return o;
  }
};

inline flatbuffers::Offset<WeatherData> CreateWeatherData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<NetworkEngineToFrontEnd::CurrentWeatherConditions> current = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NetworkEngineToFrontEnd::ForecastWeatherConditions>>> forecast = 0) {
  WeatherDataBuilder builder_(_fbb);
  builder_.add_forecast(forecast);
  builder_.add_current(current);
  return builder_.Finish();
}

inline flatbuffers::Offset<WeatherData> CreateWeatherDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<NetworkEngineToFrontEnd::CurrentWeatherConditions> current = 0,
    const std::vector<flatbuffers::Offset<NetworkEngineToFrontEnd::ForecastWeatherConditions>> *forecast = nullptr) {
  auto forecast__ = forecast ? _fbb.CreateVector<flatbuffers::Offset<NetworkEngineToFrontEnd::ForecastWeatherConditions>>(*forecast) : 0;
  return NetworkEngineToFrontEnd::CreateWeatherData(
      _fbb,
      current,
      forecast__);
}

struct DateTimeData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DateTimeDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EPOCH = 4
  };
  int64_t epoch() const {
    return GetField<int64_t>(VT_EPOCH, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_EPOCH) &&
           verifier.EndTable();
  }
};

struct DateTimeDataBuilder {
  typedef DateTimeData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_epoch(int64_t epoch) {
    fbb_.AddElement<int64_t>(DateTimeData::VT_EPOCH, epoch, 0);
  }
  explicit DateTimeDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DateTimeData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DateTimeData>(end);
    return o;
  }
};

inline flatbuffers::Offset<DateTimeData> CreateDateTimeData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t epoch = 0) {
  DateTimeDataBuilder builder_(_fbb);
  builder_.add_epoch(epoch);
  return builder_.Finish();
}

struct Packet FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PacketBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA_TYPE = 4,
    VT_DATA = 6
  };
  NetworkEngineToFrontEnd::Data data_type() const {
    return static_cast<NetworkEngineToFrontEnd::Data>(GetField<uint8_t>(VT_DATA_TYPE, 0));
  }
  const void *data() const {
    return GetPointer<const void *>(VT_DATA);
  }
  template<typename T> const T *data_as() const;
  const NetworkEngineToFrontEnd::WeatherData *data_as_WeatherData() const {
    return data_type() == NetworkEngineToFrontEnd::Data_WeatherData ? static_cast<const NetworkEngineToFrontEnd::WeatherData *>(data()) : nullptr;
  }
  const NetworkEngineToFrontEnd::DateTimeData *data_as_DateTimeData() const {
    return data_type() == NetworkEngineToFrontEnd::Data_DateTimeData ? static_cast<const NetworkEngineToFrontEnd::DateTimeData *>(data()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DATA_TYPE) &&
           VerifyOffset(verifier, VT_DATA) &&
           VerifyData(verifier, data(), data_type()) &&
           verifier.EndTable();
  }
};

template<> inline const NetworkEngineToFrontEnd::WeatherData *Packet::data_as<NetworkEngineToFrontEnd::WeatherData>() const {
  return data_as_WeatherData();
}

template<> inline const NetworkEngineToFrontEnd::DateTimeData *Packet::data_as<NetworkEngineToFrontEnd::DateTimeData>() const {
  return data_as_DateTimeData();
}

struct PacketBuilder {
  typedef Packet Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data_type(NetworkEngineToFrontEnd::Data data_type) {
    fbb_.AddElement<uint8_t>(Packet::VT_DATA_TYPE, static_cast<uint8_t>(data_type), 0);
  }
  void add_data(flatbuffers::Offset<void> data) {
    fbb_.AddOffset(Packet::VT_DATA, data);
  }
  explicit PacketBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Packet> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Packet>(end);
    return o;
  }
};

inline flatbuffers::Offset<Packet> CreatePacket(
    flatbuffers::FlatBufferBuilder &_fbb,
    NetworkEngineToFrontEnd::Data data_type = NetworkEngineToFrontEnd::Data_NONE,
    flatbuffers::Offset<void> data = 0) {
  PacketBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_data_type(data_type);
  return builder_.Finish();
}

inline bool VerifyData(flatbuffers::Verifier &verifier, const void *obj, Data type) {
  switch (type) {
    case Data_NONE: {
      return true;
    }
    case Data_WeatherData: {
      auto ptr = reinterpret_cast<const NetworkEngineToFrontEnd::WeatherData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Data_DateTimeData: {
      auto ptr = reinterpret_cast<const NetworkEngineToFrontEnd::DateTimeData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyData(
        verifier,  values->Get(i), types->GetEnum<Data>(i))) {
      return false;
    }
  }
  return true;
}

inline const NetworkEngineToFrontEnd::Packet *GetPacket(const void *buf) {
  return flatbuffers::GetRoot<NetworkEngineToFrontEnd::Packet>(buf);
}

inline const NetworkEngineToFrontEnd::Packet *GetSizePrefixedPacket(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<NetworkEngineToFrontEnd::Packet>(buf);
}

inline bool VerifyPacketBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<NetworkEngineToFrontEnd::Packet>(nullptr);
}

inline bool VerifySizePrefixedPacketBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<NetworkEngineToFrontEnd::Packet>(nullptr);
}

inline void FinishPacketBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<NetworkEngineToFrontEnd::Packet> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedPacketBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<NetworkEngineToFrontEnd::Packet> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace NetworkEngineToFrontEnd

#endif  // FLATBUFFERS_GENERATED_NETWORKENGINETOFRONTEND_NETWORKENGINETOFRONTEND_H_
